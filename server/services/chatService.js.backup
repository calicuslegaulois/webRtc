const { PrismaClient } = require('@prisma/client');

/**
 * Service de gestion du chat en temps r√©el
 * G√®re les messages, les r√©actions, et l'historique du chat
 */
class ChatService {
  constructor() {
    // Plus besoin de stockage en m√©moire - tout est en base de donn√©es
    // Configuration du chat
    this.config = {
      maxMessages: 1000, // Nombre maximum de messages par conversation
      messageRetention: 24 * 60 * 60 * 1000, // 24 heures en millisecondes
      maxMessageLength: 1000,
      allowedEmojis: ['üëç', 'üëè', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üò°', 'üéâ', 'üëé']
    };
  }

  // Obtenir une instance Prisma
  getPrisma() {
    const { PrismaClient } = require('@prisma/client');
    return new PrismaClient();
  }

  /**
   * Initialiser le chat pour une r√©union
   * @param {string} meetingId - ID de la r√©union
   * @param {Array} participants - Liste des participants
   */
  async initializeChat(meetingId, participants = []) {
    const prisma = this.getPrisma();
    try {
      // V√©rifier si la r√©union existe
      const meeting = await prisma.instantMeeting.findUnique({
        where: { id: meetingId }
      });
      
      if (!meeting) {
        throw new Error('R√©union non trouv√©e');
      }
      
      console.log(`üí¨ Chat initialis√© pour la r√©union ${meetingId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Ajouter un participant au chat
   * @param {string} meetingId - ID de la r√©union
   * @param {string} userId - ID de l'utilisateur
   */
  async addParticipant(meetingId, userId) {
    const prisma = this.getPrisma();
    try {
      // V√©rifier que la r√©union existe
      const meeting = await prisma.instantMeeting.findUnique({
        where: { id: meetingId, status: 'active' }
      });
      
      if (!meeting) {
        throw new Error('R√©union non trouv√©e ou ferm√©e');
      }
      
      console.log(`üë§ ${userId} ajout√© au chat de ${meetingId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Retirer un participant du chat
   * @param {string} meetingId - ID de la r√©union
   * @param {string} userId - ID de l'utilisateur
   */
  async removeParticipant(meetingId, userId) {
    const prisma = this.getPrisma();
    try {
      // Retirer la main lev√©e si applicable
      await this.lowerHand(meetingId, userId);
      console.log(`üë§ ${userId} retir√© du chat de ${meetingId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Envoyer un message dans le chat
   * @param {string} meetingId - ID de la r√©union
   * @param {string} userId - ID de l'utilisateur
   * @param {string} username - Nom d'utilisateur
   * @param {string} message - Contenu du message
   * @param {string} type - Type de message (text, system, announcement)
   * @returns {Object} Message cr√©√©
   */
  async sendMessage(meetingId, userId, username, message, type = 'text') {
    const prisma = this.getPrisma();
    try {
      // V√©rifier que la r√©union existe
      const meeting = await prisma.instantMeeting.findUnique({
        where: { id: meetingId, status: 'active' }
      });
      
      if (!meeting) {
        throw new Error('Chat non trouv√© pour cette r√©union');
      }

      // Validation du message
      if (!message || message.trim().length === 0) {
        throw new Error('Le message ne peut pas √™tre vide');
      }

      if (message.length > this.config.maxMessageLength) {
        throw new Error(`Le message ne peut pas d√©passer ${this.config.maxMessageLength} caract√®res`);
      }

      // Nettoyer le message (protection XSS basique)
      const cleanMessage = this.sanitizeMessage(message);

      // Cr√©er le message en base de donn√©es
      const messageObj = await prisma.chatMessage.create({
        data: {
          meetingId,
          userId: userId || null,
          username,
          message: cleanMessage,
          type,
          edited: false
        }
      });

      // Nettoyer les anciens messages si n√©cessaire
      await this.cleanupOldMessages(meetingId);

      console.log(`üí¨ Message envoy√© par ${username} dans ${meetingId}: ${cleanMessage.substring(0, 50)}...`);

      return messageObj;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
  }

  /**
   * Ajouter une r√©action √† un message
   * @param {string} meetingId - ID de la r√©union
   * @param {string} messageId - ID du message
   * @param {string} userId - ID de l'utilisateur
   * @param {string} emoji - Emoji de r√©action
   * @returns {Object} R√©action cr√©√©e
   */
  async addReaction(meetingId, messageId, userId, emoji) {
    const prisma = this.getPrisma();
    try {
      // V√©rifier que l'emoji est autoris√©
      if (!this.config.allowedEmojis.includes(emoji)) {
        throw new Error('Emoji non autoris√©');
      }

      // V√©rifier que le message existe
      const message = await prisma.chatMessage.findUnique({
        where: { id: messageId, meetingId }
      });
      
      if (!message) {
        throw new Error('Message non trouv√©');
      }

      // V√©rifier si la r√©action existe d√©j√†
      const existingReaction = await prisma.messageReaction.findUnique({
        where: {
          messageId_userId_emoji: {
            messageId,
            userId,
            emoji
          }
        }
      });

      if (existingReaction) {
        throw new Error('R√©action d√©j√† ajout√©e');
      }

      // Cr√©er la r√©action
      await prisma.messageReaction.create({
        data: {
          messageId,
          userId,
          emoji
        }
      });

      // Compter les r√©actions pour cet emoji
      const count = await prisma.messageReaction.count({
        where: { messageId, emoji }
      });

      console.log(`üòä R√©action ${emoji} ajout√©e par ${userId} au message ${messageId}`);

      return {
        messageId,
        emoji,
        count,
        users: await this.getReactionUsers(messageId, emoji)
      };
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur add reaction:', error);
      throw error;
    }
  }

  /**
   * Retirer une r√©action d'un message
   * @param {string} meetingId - ID de la r√©union
   * @param {string} messageId - ID du message
   * @param {string} userId - ID de l'utilisateur
   * @param {string} emoji - Emoji de r√©action
   * @returns {Object} R√©action mise √† jour
   */
  async removeReaction(meetingId, messageId, userId, emoji) {
    const prisma = this.getPrisma();
    try {
      // Supprimer la r√©action
      const deletedReaction = await prisma.messageReaction.deleteMany({
        where: {
          messageId,
          userId,
          emoji
        }
      });

      if (deletedReaction.count === 0) {
        return null;
      }

      // Compter les r√©actions restantes pour cet emoji
      const count = await prisma.messageReaction.count({
        where: { messageId, emoji }
      });

      return {
        messageId,
        emoji,
        count,
        users: await this.getReactionUsers(messageId, emoji)
      };
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur remove reaction:', error);
      throw error;
    }
  }

  /**
   * Lever la main dans une r√©union
   * @param {string} meetingId - ID de la r√©union
   * @param {string} userId - ID de l'utilisateur
   * @param {string} username - Nom d'utilisateur
   * @returns {boolean} True si la main a √©t√© lev√©e
   */
  async raiseHand(meetingId, userId, username) {
    const prisma = this.getPrisma();
    try {
      // V√©rifier si la main est d√©j√† lev√©e
      const existingHand = await prisma.raisedHand.findFirst({
        where: {
          meetingId,
          OR: [
            { userId },
            { username: userId } // Fallback si userId est en fait un username
          ],
          loweredAt: null
        }
      });

      if (existingHand) {
        return false; // Main d√©j√† lev√©e
      }

      // Cr√©er l'entr√©e de main lev√©e
      await prisma.raisedHand.create({
        data: {
          meetingId,
          userId: userId || null,
          username
        }
      });
      
      // Ajouter un message syst√®me
      await this.sendMessage(meetingId, userId, username, `${username} a lev√© la main`, 'system');
      
      console.log(`‚úã ${username} a lev√© la main dans ${meetingId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur raise hand:', error);
      throw error;
    }
  }

  /**
   * Baisser la main dans une r√©union
   * @param {string} meetingId - ID de la r√©union
   * @param {string} userId - ID de l'utilisateur
   * @param {string} username - Nom d'utilisateur
   * @returns {boolean} True si la main a √©t√© baiss√©e
   */
  async lowerHand(meetingId, userId, username) {
    const prisma = this.getPrisma();
    try {
      // Trouver la main lev√©e active
      const raisedHand = await prisma.raisedHand.findFirst({
        where: {
          meetingId,
          OR: [
            { userId },
            { username: userId } // Fallback si userId est en fait un username
          ],
          loweredAt: null
        }
      });

      if (!raisedHand) {
        return false; // Aucune main lev√©e trouv√©e
      }

      // Marquer la main comme baiss√©e
      await prisma.raisedHand.update({
        where: { id: raisedHand.id },
        data: { loweredAt: new Date() }
      });
      
      // Ajouter un message syst√®me
      await this.sendMessage(meetingId, userId, username, `${username} a baiss√© la main`, 'system');
      
      console.log(`‚úã ${username} a baiss√© la main dans ${meetingId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur lower hand:', error);
      throw error;
    }
  }

  /**
   * Obtenir les messages d'un chat
   * @param {string} meetingId - ID de la r√©union
   * @param {number} limit - Nombre maximum de messages √† retourner
   * @param {Date} since - R√©cup√©rer les messages depuis cette date
   * @returns {Array} Liste des messages
   */
  async getMessages(meetingId, limit = 50, since = null) {
    const prisma = this.getPrisma();
    try {
      const whereClause = { meetingId };
      
      if (since) {
        whereClause.timestamp = { gt: since };
      }

      const messages = await prisma.chatMessage.findMany({
        where: whereClause,
        orderBy: { timestamp: 'asc' },
        take: limit || undefined,
        include: {
          reactions: {
            select: {
              userId: true,
              emoji: true
            }
          }
        }
      });

      // Grouper les r√©actions par emoji
      return messages.map(msg => ({
        id: msg.id,
        meetingId: msg.meetingId,
        userId: msg.userId,
        username: msg.username,
        message: msg.message,
        type: msg.type,
        timestamp: msg.timestamp,
        edited: msg.edited,
        editedAt: msg.editedAt,
        reactions: this.groupReactionsByEmoji(msg.reactions)
      }));
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur get messages:', error);
      return [];
    }
  }

  /**
   * Obtenir les utilisateurs qui ont lev√© la main
   * @param {string} meetingId - ID de la r√©union
   * @returns {Array} Liste des utilisateurs avec la main lev√©e
   */
  async getRaisedHands(meetingId) {
    const prisma = this.getPrisma();
    try {
      const raisedHands = await prisma.raisedHand.findMany({
        where: {
          meetingId,
          loweredAt: null
        },
        select: {
          userId: true,
          username: true,
          raisedAt: true
        }
      });

      return raisedHands;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur get raised hands:', error);
      return [];
    }
  }

  /**
   * Obtenir les statistiques d'un chat
   * @param {string} meetingId - ID de la r√©union
   * @returns {Object} Statistiques du chat
   */
  async getChatStats(meetingId) {
    const prisma = this.getPrisma();
    try {
      const meeting = await prisma.instantMeeting.findUnique({
        where: { id: meetingId },
        include: {
          participants: {
            where: { leftAt: null }
          },
          messages: true,
          raisedHands: {
            where: { loweredAt: null }
          }
        }
      });

      if (!meeting) {
        return null;
      }

      // Compter les messages par utilisateur
      const messagesByUser = {};
      const messageTypes = {};
      
      meeting.messages.forEach(msg => {
        const userId = msg.userId || 'anonymous';
        messagesByUser[userId] = (messagesByUser[userId] || 0) + 1;
        messageTypes[msg.type] = (messageTypes[msg.type] || 0) + 1;
      });

      // Compter les r√©actions
      const totalReactions = await prisma.messageReaction.count({
        where: {
          message: { meetingId }
        }
      });

      return {
        totalMessages: meeting.messages.length,
        totalParticipants: meeting.participants.length,
        messagesByUser,
        messageTypes,
        totalReactions,
        createdAt: meeting.createdAt,
        lastActivity: meeting.messages.length > 0 ? 
          meeting.messages[meeting.messages.length - 1].timestamp : 
          meeting.createdAt,
        raisedHands: meeting.raisedHands.length
      };
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur get chat stats:', error);
      return null;
    }
  }

  /**
   * Nettoyer un message (protection XSS basique)
   * @param {string} message - Message √† nettoyer
   * @returns {string} Message nettoy√©
   */
  sanitizeMessage(message) {
    return message
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;')
      .trim();
  }

  /**
   * Nettoyer les messages anciens d'une r√©union
   * @param {string} meetingId - ID de la r√©union
   */
  async cleanupOldMessages(meetingId) {
    const prisma = this.getPrisma();
    try {
      const messageCount = await prisma.chatMessage.count({
        where: { meetingId }
      });

      if (messageCount > this.config.maxMessages) {
        const messagesToDelete = messageCount - this.config.maxMessages;
        
        // Supprimer les plus anciens messages
        const oldestMessages = await prisma.chatMessage.findMany({
          where: { meetingId },
          orderBy: { timestamp: 'asc' },
          take: messagesToDelete,
          select: { id: true }
        });

        const messageIds = oldestMessages.map(msg => msg.id);
        
        // Supprimer les r√©actions associ√©es
        await prisma.messageReaction.deleteMany({
          where: { messageId: { in: messageIds } }
        });

        // Supprimer les messages
        await prisma.chatMessage.deleteMany({
          where: { id: { in: messageIds } }
        });

        console.log(`üßπ ${messagesToDelete} anciens messages supprim√©s de ${meetingId}`);
      }    } finally {
      await prisma.$disconnect();
    } catch (error) {
      console.error('‚ùå Erreur cleanup messages:', error);
    }
  }

  /**
   * Nettoyer les chats anciens
   * @param {number} maxAge - √Çge maximum en millisecondes
   */
  async cleanupOldChats(maxAge = this.config.messageRetention) {
    const prisma = this.getPrisma();
    try {
      const cutoffDate = new Date(Date.now() - maxAge);
      
      // Marquer les r√©unions anciennes comme ferm√©es
      const result = await prisma.instantMeeting.updateMany({
        where: {
          status: 'active',
          createdAt: { lt: cutoffDate }
        },
        data: {
          status: 'ended',
          endedAt: new Date()
        }
      });

      console.log(`üßπ ${result.count} r√©unions anciennes ferm√©es`);
      return result.count;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur cleanup chats:', error);
      return 0;
    }
  }

  /**
   * Fermer le chat d'une r√©union
   * @param {string} meetingId - ID de la r√©union
   */
  async closeChat(meetingId) {
    const prisma = this.getPrisma();
    try {
      await prisma.instantMeeting.update({
        where: { id: meetingId },
        data: {
          status: 'ended',
          endedAt: new Date()
        }
      });

      console.log(`üîí Chat ferm√© pour la r√©union ${meetingId}`);    } finally {
      await prisma.$disconnect();
    } catch (error) {
      console.error('‚ùå Erreur close chat:', error);
      throw error;
    }
  }

  /**
   * Obtenir toutes les conversations actives
   * @returns {Array} Liste des conversations actives
   */
  async getActiveChats() {
    const prisma = this.getPrisma();
    try {
      const activeMeetings = await prisma.instantMeeting.findMany({
        where: { status: 'active' },
        select: { id: true }
      });

      const chatsWithStats = await Promise.all(
        activeMeetings.map(async (meeting) => ({
          meetingId: meeting.id,
          stats: await this.getChatStats(meeting.id)
        }))
      );

      return chatsWithStats;
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur get active chats:', error);
      return [];
    }
  }

  /**
   * Grouper les r√©actions par emoji
   * @param {Array} reactions - Liste des r√©actions
   * @returns {Object} R√©actions group√©es par emoji
   */
  groupReactionsByEmoji(reactions) {
    const grouped = {};
    
    reactions.forEach(reaction => {
      if (!grouped[reaction.emoji]) {
        grouped[reaction.emoji] = {
          count: 0,
          users: []
        };
      }
      grouped[reaction.emoji].count++;
      grouped[reaction.emoji].users.push(reaction.userId);
    });

    return grouped;
  }

  /**
   * Obtenir les utilisateurs d'une r√©action
   * @param {string} messageId - ID du message
   * @param {string} emoji - Emoji
   * @returns {Array} Liste des utilisateurs
   */
  async getReactionUsers(messageId, emoji) {
    const prisma = this.getPrisma();
    try {
      const reactions = await prisma.messageReaction.findMany({
        where: { messageId, emoji },
        select: { userId: true }
      });

      return reactions.map(r => r.userId);
    } catch (error) {
      console.error('‚ùå Erreur:', error);
      throw error;
    } finally {
      await prisma.$disconnect();
    }
      console.error('‚ùå Erreur get reaction users:', error);
      return [];
    }
  }
}

module.exports = ChatService;
